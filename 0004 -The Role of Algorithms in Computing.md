  ### I Fundamentos

Esta parte irá levá-lo a refletir sobre o design e a análise de algoritmos. Pretende ser uma introdução suave sobre como especificamos algoritmos, algumas das estratégias de design que usaremos ao longo deste livro e muitas das ideias fundamentais usadas na análise de algoritmos. As partes subsequentes deste livro serão construídas sobre essa base.

O Capítulo 1 fornece uma visão geral de algoritmos e seu lugar nos sistemas de computação modernos. Este capítulo define o que é um algoritmo e lista alguns exemplos. Ele também argumenta que devemos considerar os algoritmos como uma tecnologia, ao lado de tecnologias como hardware rápido, interfaces gráficas de usuário, sistemas orientados a objetos e redes.

No Capítulo 2, encontramos nossos primeiros algoritmos, que resolvem o problema de ordenar uma sequência de n números. Eles são escritos em pseudocódigo, que, embora não seja diretamente traduzível para nenhuma linguagem de programação convencional, transmite a estrutura do algoritmo de forma clara o suficiente para que você consiga implementá-lo na linguagem de sua escolha. Os algoritmos de ordenação que examinamos são o insertion sort, que utiliza uma abordagem incremental, e o merge sort, que utiliza uma técnica recursiva conhecida como "dividir e conquistar". Embora o tempo necessário aumente com o valor de n, a taxa de aumento difere entre os dois algoritmos. Determinamos esses tempos de execução no Capítulo 2 e desenvolvemos uma notação útil para expressá-los.

O Capítulo 3 define precisamente essa notação, que chamamos de notação assintótica. Ele começa definindo várias notações assintóticas, que usamos para limitar os tempos de execução do algoritmo de cima e/ou de baixo. O restante do Capítulo 3 é principalmente uma apresentação de notação matemática, mais para garantir que o uso da notação corresponda ao deste livro do que para ensinar novos conceitos matemáticos.

Capítulo 4 aprofunda ainda mais o método de "dividir e conquistar" introduzido no Capítulo 2. Ele fornece exemplos adicionais de algoritmos de "dividir e conquistar", incluindo o surpreendente método de Strassen para multiplicar duas matrizes quadradas. O Capítulo 4 apresenta métodos para resolver recorrências, que são úteis para descrever os tempos de execução de algoritmos recursivos. Uma técnica poderosa é o "método mestre", que frequentemente usamos para resolver recorrências que surgem de algoritmos de "dividir e conquistar". Embora grande parte do Capítulo 4 seja dedicada a provar a correção do método mestre, você pode pular essa prova e ainda utilizar o método mestre.

O Capítulo 5 introduz a análise probabilística e algoritmos randomizados. Normalmente, usamos a análise probabilística para determinar o tempo de execução de um algoritmo em casos nos quais, devido à presença de uma distribuição de probabilidade inerente, o tempo de execução pode variar em diferentes entradas do mesmo tamanho. Em alguns casos, assumimos que as entradas seguem uma distribuição de probabilidade conhecida, para que estejamos calculando a média do tempo de execução sobre todas as entradas possíveis. Em outros casos, a distribuição de probabilidade não vem das entradas, mas das escolhas aleatórias feitas durante o curso do algoritmo. Um algoritmo cujo comportamento é determinado não apenas por sua entrada, mas pelos valores produzidos por um gerador de números aleatórios é um algoritmo randomizado. Podemos usar algoritmos randomizados para impor uma distribuição de probabilidade nas entradas, garantindo assim que nenhuma entrada específica sempre resulte em baixo desempenho, ou mesmo para limitar a taxa de erro de algoritmos que têm permissão para produzir resultados incorretos em uma base limitada.

Os Apêndices A-D contêm outro material matemático que você encontrará útil ao ler este livro. Provavelmente, você já viu grande parte do material nos capítulos do apêndice antes de ler este livro (embora as definições específicas e convenções notacionais que usamos possam diferir em alguns casos do que você viu no passado), então você deve pensar nos Apêndices como material de referência. Por outro lado, é provável que você ainda não tenha visto a maior parte do material na Parte I. Todos os capítulos da Parte I e os Apêndices são escritos com um estilo tutorial.

  ### 1 O Papel dos Algoritmos na Computação

O que são algoritmos? Por que o estudo de algoritmos vale a pena? Qual é o papel
dos algoritmos em relação a outras tecnologias usadas em computadores? Neste capítulo,
responderemos a essas perguntas.

---------------------------------------------------------------------------------------------------------

  ####    1.1 Algoritmos

De forma informal, um algoritmo é qualquer procedimento computacional bem definido que recebe algum valor ou conjunto de valores como entrada e produz algum valor ou conjunto de valores como saída. Um algoritmo é, portanto, uma sequência de passos computacionais que transformam a entrada na saída.

Podemos também ver um algoritmo como uma ferramenta para resolver um problema computacional bem especificado. A declaração do problema especifica, em termos gerais, a relação desejada entre entrada e saída. O algoritmo descreve um procedimento computacional específico para alcançar essa relação de entrada/saída.

Por exemplo, podemos precisar ordenar uma sequência de números em ordem não decrescente. Esse problema surge frequentemente na prática e oferece um terreno fértil para introduzir muitas técnicas de design padrão e ferramentas de análise. Aqui está como definimos formalmente o problema de ordenação:

**Entrada:** Uma sequência de n números (a1, a2, ..., an).

**Saída:** Uma permutação (reordenação) (a'1, a'2, ..., a'n) da sequência de entrada tal que a'1  <= a'2 <= ... <= a'n.

Por exemplo, dada a sequência de entrada (31, 41, 59, 26, 41, 58), um algoritmo de ordenação retorna como saída a sequência (26, 31, 41, 41, 58, 59). Tal sequência de entrada é chamada de instância do problema de ordenação. Em geral, uma instância de um problema consiste na entrada (satisfazendo quaisquer restrições impostas na declaração do problema) necessária para calcular uma solução para o problema.

Como muitos programas o utilizam como uma etapa intermediária, a ordenação é uma operação fundamental em ciência da computação. Como resultado, temos um grande número de bons algoritmos de ordenação à nossa disposição. Qual algoritmo é o melhor para uma aplicação específica depende, entre outros fatores, do número de itens a serem ordenados, da extensão em que os itens já estão um pouco ordenados, de possíveis restrições nos valores dos itens, da arquitetura do computador e do tipo de dispositivos de armazenamento a serem usados: memória principal, discos ou até mesmo fitas.

Diz-se que um algoritmo está correto se, para cada instância de entrada, ele termina com a saída correta. Dizemos que um algoritmo correto resolve o problema computacional dado. Um algoritmo incorreto pode não terminar em alguns casos de entrada, ou pode encerrar com uma resposta incorreta. Contrariamente ao que se poderia esperar, algoritmos incorretos às vezes podem ser úteis, se pudermos controlar sua taxa de erro. Veremos um exemplo de um algoritmo com uma taxa de erro controlável no Capítulo 31, quando estudarmos algoritmos para encontrar números primos grandes. No entanto, normalmente, estaremos preocupados apenas com algoritmos corretos.

Um algoritmo pode ser especificado em inglês, como um programa de computador ou até mesmo como um projeto de hardware. O único requisito é que a especificação forneça uma descrição precisa do procedimento computacional a ser seguido.

  #### Quais tipos de problemas são resolvidos por algoritmos?

A ordenação está longe de ser o único problema computacional para o qual algoritmos foram desenvolvidos. (Você provavelmente suspeitou disso ao ver o tamanho deste livro.) Aplicações práticas de algoritmos são onipresentes e incluem os seguintes exemplos:

O Projeto Genoma Humano fez grandes avanços em direção aos objetivos de identificar todos os 100.000 genes no DNA humano, determinar as sequências dos 3 bilhões de pares de bases químicas que compõem o DNA humano, armazenar essas informações em bancos de dados e desenvolver ferramentas para análise de dados. Cada um desses passos requer algoritmos sofisticados. Embora as soluções para os vários problemas envolvidos estejam além do escopo deste livro, muitos métodos para resolver esses problemas biológicos utilizam ideias de vários capítulos deste livro, permitindo assim que os cientistas realizem tarefas utilizando recursos de maneira eficiente. As economias são em tempo, tanto humano quanto de máquina, e em dinheiro, já que mais informações podem ser extraídas das técnicas laboratoriais.

A Internet permite que pessoas ao redor do mundo acessem e recuperem rapidamente grandes quantidades de informações. Com o auxílio de algoritmos inteligentes, os sites na Internet conseguem gerenciar e manipular esse grande volume de dados. Exemplos de problemas que fazem uso essencial de algoritmos incluem encontrar rotas eficientes nas quais os dados viajarão (técnicas para resolver tais problemas aparecem no Capítulo 24) e usar um mecanismo de busca para encontrar rapidamente páginas em que determinadas informações residem (técnicas relacionadas são abordadas nos Capítulos 11 e 32).

O comércio eletrônico permite que bens e serviços sejam negociados e trocados eletronicamente, e depende da privacidade de informações pessoais, como números de cartão de crédito, senhas e extratos bancários. As tecnologias centrais usadas no comércio eletrônico incluem criptografia de chave pública e assinaturas digitais (abordadas no Capítulo 31), que se baseiam em algoritmos numéricos e teoria dos números.

Empresas de manufatura e outras empresas comerciais frequentemente precisam alocar recursos escassos da maneira mais benéfica possível. Uma empresa de petróleo pode querer saber onde colocar seus poços para maximizar seu lucro esperado. Um candidato político pode querer determinar onde gastar dinheiro comprando publicidade de campanha para maximizar as chances de ganhar uma eleição. Uma companhia aérea pode desejar atribuir tripulações a voos da maneira menos dispendiosa possível, garantindo que cada voo seja coberto e que as regulamentações governamentais relativas à programação de tripulações sejam atendidas. Um provedor de serviços de Internet pode querer determinar onde alocar recursos adicionais para atender seus clientes de maneira mais eficaz. Todos esses são exemplos de problemas que podem ser resolvidos usando programação linear, que estudaremos no Capítulo 29.

Embora alguns detalhes desses exemplos estejam além do escopo deste livro, fornecemos técnicas subjacentes que se aplicam a esses problemas e áreas de problema. Também mostramos como resolver muitos problemas específicos, incluindo os seguintes:
 
1. Nos é fornecido um mapa de estradas no qual a distância entre cada par de interseções adjacentes está marcada, e desejamos determinar a rota mais curta de uma interseção para outra. O número de rotas possíveis pode ser enorme, mesmo se desconsiderarmos rotas que se cruzam. Como escolhemos a rota mais curta entre todas as possíveis? Aqui, modelamos o mapa de estradas (que é ele próprio um modelo das estradas reais) como um grafo (que encontraremos na Parte VI e no Apêndice B), e desejamos encontrar o caminho mais curto de um vértice a outro no grafo. Veremos como resolver esse problema de maneira eficiente no Capítulo 24.

2. Nos são fornecidas duas sequências ordenadas de símbolos, X = {x1, x2, ..., xm} e Y = {y1, y2, ..., yn}, e desejamos encontrar uma subsequência comum mais longa de X e Y. Uma subsequência de X é simplesmente X com alguns (ou possivelmente todos ou nenhum) de seus elementos removidos. Por exemplo, uma subsequência de {A, B, C, D, E, F, G} seria {B, C, E, G}. O comprimento de uma subsequência comum mais longa de X e Y fornece uma medida de quão semelhantes são essas duas sequências. Veremos no Capítulo 15 como usar uma técnica geral conhecida como programação dinâmica para resolver esse problema de maneira muito mais eficiente.

3. Nos é dada uma concepção mecânica em termos de uma biblioteca de peças, onde cada peça pode incluir instâncias de outras peças, e precisamos listar as peças em ordem para que cada peça apareça antes de qualquer peça que a utilize. Se o design consistir em n peças, então existem n! ordens possíveis, onde n! denota a função fatorial. Como a função fatorial cresce mais rápido do que até mesmo uma função exponencial, não podemos gerar cada ordem possível de maneira viável e depois verificar se, dentro dessa ordem, cada peça aparece antes das peças que a utilizam (a menos que tenhamos apenas algumas peças). Esse problema é uma instância de ordenação topológica, e veremos no Capítulo 22 como resolver esse problema de maneira eficiente.

4. Nos são dados n pontos no plano, e desejamos encontrar a envoltória convexa desses pontos. A envoltória convexa é o menor polígono convexo que contém os pontos. Intuitivamente, podemos pensar em cada ponto como sendo representado por um prego saindo de uma placa. A envoltória convexa seria representada por uma borracha apertada que cerca todos os pregos. Cada prego ao redor do qual a borracha faz uma curva é um vértice da envoltória convexa. (Veja a Figura 33.6 na página 1029 para um exemplo.) Qualquer um dos 2n subconjuntos dos pontos pode ser os vértices da envoltória convexa. Saber quais pontos são vértices da envoltória convexa não é suficiente, pois também precisamos saber a ordem em que aparecem. Portanto, existem muitas escolhas para os vértices da envoltória convexa. O Capítulo 33 apresenta dois bons métodos para encontrar a envoltória convexa.

Essas listas estão longe de serem exaustivas (como você provavelmente já suspeitou pelo tamanho deste livro), mas apresentam duas características comuns a muitos problemas algorítmicos interessantes:

1. Elas têm muitas soluções candidatas, sendo que a grande maioria delas não resolve o problema em questão. Encontrar uma que resolva, ou uma que seja a "melhor", pode representar um desafio significativo.

2. Elas têm aplicações práticas. Dos problemas na lista acima, encontrar o caminho mais curto fornece exemplos mais simples. Uma empresa de transporte, como uma empresa de caminhões ou ferrovia, tem interesse financeiro em encontrar os caminhos mais curtos por meio de uma rede rodoviária ou ferroviária, pois trajetos mais curtos resultam em menores custos de mão de obra e combustível. Ou um nó de roteamento na Internet pode precisar encontrar o caminho mais curto através da rede para rotear uma mensagem rapidamente. Ou uma pessoa que deseja dirigir de Nova York para Boston pode querer encontrar direções de direção em um site apropriado, ou ela pode usar seu GPS enquanto dirige.

 Nem todo problema resolvido por algoritmos tem um conjunto facilmente identificável de soluções candidatas. Por exemplo, suponha que nos sejam dados um conjunto de valores numéricos representando amostras de um sinal, e queremos calcular a transformada discreta de Fourier dessas amostras. A transformada discreta de Fourier converte o domínio do tempo para o domínio da frequência, produzindo um conjunto de coeficientes numéricos, para que possamos determinar a intensidade de várias frequências no sinal amostrado. Além de estar no cerne do processamento de sinais, as transformadas discretas de Fourier têm aplicações em compressão de dados e multiplicação de polinômios e inteiros grandes. O Capítulo 30 apresenta um algoritmo eficiente, a Transformada Rápida de Fourier (comumente chamada de FFT), para esse problema, e o capítulo também esboça o design de um circuito de hardware para calcular a FFT.

  #### Estruturas de dados

Este livro também contém várias estruturas de dados. Uma estrutura de dados é uma maneira de armazenar e organizar dados para facilitar o acesso e as modificações. Nenhuma única estrutura de dados funciona bem para todos os propósitos, portanto, é importante conhecer os pontos fortes e as limitações de várias delas.

  #### Técnica

Embora você possa usar este livro como um "livro de receitas" para algoritmos, você pode, eventualmente, encontrar um problema para o qual não consiga encontrar prontamente um algoritmo publicado (muitos dos exercícios e problemas deste livro, por exemplo). Este livro ensinará técnicas de design e análise de algoritmos para que você possa desenvolver algoritmos por conta própria, mostrar que eles dão a resposta correta e entender sua eficiência. Diferentes capítulos abordam aspectos diferentes da resolução de problemas algorítmicos. Alguns capítulos abordam problemas específicos, como encontrar medianas e estatísticas de ordem no Capítulo 9, calcular árvores de abrangência mínima no Capítulo 23 e determinar um fluxo máximo em uma rede no Capítulo 26. Outros capítulos abordam técnicas, como "dividir e conquistar" no Capítulo 4, programação dinâmica no Capítulo 15 e análise amortizada no Capítulo 17.

  #### Problemas Difíceis

A maior parte deste livro trata de algoritmos eficientes. Nossa medida usual de eficiência é a velocidade, ou seja, quanto tempo um algoritmo leva para produzir seu resultado. No entanto, existem alguns problemas para os quais não se conhece uma solução eficiente. O Capítulo 34 estuda um subconjunto interessante desses problemas, conhecidos como NP-completos.

Por que os problemas NP-completos são interessantes? Primeiro, embora nunca tenha sido encontrada uma solução eficiente para um problema NP-completo, nunca foi provado que um algoritmo eficiente para um deles não pode existir. Em outras palavras, ninguém sabe se algoritmos eficientes existem ou não para problemas NP-completos. Em segundo lugar, o conjunto de problemas NP-completos tem a notável propriedade de que se um algoritmo eficiente existe para qualquer um deles, então algoritmos eficientes existem para todos eles. Essa relação entre os problemas NP-completos torna a falta de soluções eficientes ainda mais intrigante. Terceiro, vários problemas NP-completos são semelhantes, mas não idênticos, a problemas para os quais conhecemos algoritmos eficientes. Os cientistas da computação ficam intrigados com como uma pequena mudança na declaração do problema pode causar uma grande mudança na eficiência do algoritmo mais conhecido.

Você deve conhecer os problemas NP-completos porque alguns deles surgem surpreendentemente frequentemente em aplicações reais. Se você for chamado a produzir um algoritmo eficiente para um problema NP-completo, é provável que gaste muito tempo em uma busca infrutífera. Se puder mostrar que

 o problema é NP-completo, poderá, em vez disso, gastar seu tempo desenvolvendo um algoritmo eficiente que fornece uma solução boa, embora não a melhor possível.

Como exemplo concreto, considere uma empresa de entrega com um depósito central. A cada dia, ela carrega cada caminhão de entrega no depósito e o envia para entregar mercadorias em vários endereços. No final do dia, cada caminhão deve voltar ao depósito para que esteja pronto para ser carregado no próximo dia. Para reduzir custos, a empresa deseja selecionar uma ordem de paradas de entrega que resulte na menor distância total percorrida por cada caminhão. Esse problema é o conhecido "problema do caixeiro-viajante" e é NP-completo. Não há um algoritmo eficiente conhecido. No entanto, sob certas suposições, conhecemos algoritmos eficientes que fornecem uma distância total que não está muito acima da menor possível. O Capítulo 35 discute tais "algoritmos aproximados".

  #### Paralelismo

Por muitos anos, podíamos contar com o aumento constante nas velocidades dos relógios dos processadores. No entanto, limitações físicas representam um obstáculo fundamental para o aumento contínuo das velocidades dos relógios: porque a densidade de energia aumenta superlinearmente com a velocidade do relógio, os chips correm o risco de derreter uma vez que suas velocidades de relógio se tornam suficientemente altas. Para realizar mais computações por segundo, os chips estão sendo projetados para conter não apenas um, mas vários "núcleos" de processamento. Podemos comparar esses computadores multicore a vários computadores sequenciais em um único chip; em outras palavras, eles são um tipo de "computador paralelo". Para obter o melhor desempenho desses computadores multicore, precisamos projetar algoritmos levando em consideração o paralelismo. O Capítulo 27 apresenta um modelo para algoritmos "multithreaded", que tiram vantagem de vários núcleos. Esse modelo tem vantagens do ponto de vista teórico e é a base de vários programas de computador bem-sucedidos, incluindo um programa de xadrez campeão.
