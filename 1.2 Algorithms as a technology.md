  ### 1.2 Algoritmos como uma tecnologia

Suponha que os computadores fossem infinitamente rápidos e a memória do computador fosse gratuita. Haveria alguma razão para estudar algoritmos? A resposta é sim, mesmo que seja apenas porque você ainda gostaria de demonstrar que seu método de solução termina e o faz com a resposta correta. Se os computadores fossem infinitamente rápidos, qualquer método correto para resolver um problema serviria. Você provavelmente gostaria que sua implementação estivesse dentro dos limites das boas práticas de engenharia de software (por exemplo, sua implementação deve ser bem projetada e documentada), mas você usaria mais frequentemente o método mais fácil de implementar. Claro, os computadores podem ser rápidos, mas não são infinitamente rápidos. E a memória pode ser barata, mas não é gratuita. O tempo de computação é, portanto, um recurso limitado, assim como o espaço na memória. Você deve usar esses recursos com sabedoria, e algoritmos que são eficientes em termos de tempo ou espaço ajudarão você a fazer isso.

  #### Eficiência

Diferentes algoritmos desenvolvidos para resolver o mesmo problema muitas vezes diferem drasticamente em eficiência. Essas diferenças podem ser muito mais significativas do que as diferenças de hardware e software.

Como exemplo, no Capítulo 2, veremos dois algoritmos para ordenação. O primeiro, conhecido como ordenação por inserção, leva um tempo aproximadamente igual a c1n² para ordenar n itens, onde c1 é uma constante que não depende de n. Ou seja, leva um tempo aproximadamente proporcional a n². O segundo, merge sort, leva um tempo aproximadamente igual a c2n lg n, onde lg n representa o logaritmo na base 2 de n e c2 é outra constante que também não depende de n. A ordenação por inserção geralmente tem um fator constante menor do que o merge sort, de modo que c1 < c2. Veremos que os fatores constantes podem ter muito menos impacto no tempo de execução do que a dependência do tamanho de entrada n. Vamos escrever o tempo de execução da ordenação por inserção como c1n² e o tempo de execução do merge sort como c2n lg n. Então vemos que onde a ordenação por inserção tem um fator de n em seu tempo de execução, o merge sort tem um fator de lg n, que é muito menor. (Por exemplo, quando n = 1000, lg n é aproximadamente 10, e quando n é igual a um milhão, lg n é aproximadamente apenas 20.) Embora a ordenação por inserção geralmente seja mais rápida que o merge sort para tamanhos pequenos de entrada, uma vez que o tamanho da entrada n se torna suficientemente grande, a vantagem do merge sort de lg n em relação a n mais do que compensará a diferença nos fatores constantes. Não importa quão menor seja c1 em relação a c2, sempre haverá um ponto de virada além do qual o merge sort é mais rápido. Para um exemplo concreto, comparemos um computador mais rápido (computador A) executando a ordenação por inserção contra um computador mais lento (computador B) executando o merge sort. Ambos devem ordenar uma matriz de 10 milhões de números. (Embora 10 milhões de números possam parecer muitos, se os números forem inteiros de oito bytes, então a entrada ocupa cerca de 80 megabytes, o que cabe na memória até mesmo de um laptop barato muitas vezes.) Suponha que o computador A execute 10 bilhões de instruções por segundo (mais rápido do que qualquer computador sequencial único no momento desta escrita) e o computador B execute apenas 10 milhões de instruções por segundo, de modo que o computador A seja 1000 vezes mais rápido que o computador B em potência bruta de computação. Para tornar a diferença ainda mais dramática, suponha que o programador mais astuto do mundo codifica a ordenação por inserção em linguagem de máquina para o computador A, e o código resultante requer 2n² instruções para ordenar n números. Suponha ainda que um programador médio implementa o merge sort, usando uma linguagem de alto nível com um compilador ineficiente, e que o código resultante leva 50n lg n instruções. Para ordenar 10 milhões de números, o computador A leva 10 milhões de segundos, enquanto o computador B leva 10 segundos. Usando um algoritmo cujo tempo de execução cresce mais lentamente, mesmo com um compilador ruim, o computador B é mais de 17 vezes mais rápido que o computador A! A vantagem do merge sort é ainda mais pronunciada quando ordenamos 100 milhões de números: onde a ordenação por inserção leva mais de 23 dias, o merge sort leva menos de quatro horas. Em geral, à medida que o tamanho do problema aumenta, aumenta também a vantagem relativa do merge sort.

  #### Algoritmos e outras tecnologias

O exemplo acima mostra que devemos considerar os algoritmos, assim como o hardware do computador, como uma tecnologia. O desempenho total do sistema depende da escolha de algoritmos eficientes tanto quanto da escolha de hardware rápido. Assim como avanços rápidos estão sendo feitos em outras tecnologias de computadores, eles também estão sendo feitos em algoritmos. Você pode se perguntar se os algoritmos são realmente tão importantes nos computadores contemporâneos diante de outras tecnologias avançadas, como arquiteturas de computadores e tecnologias de fabricação avançadas, interfaces gráficas de usuário (GUIs) fáceis de usar e intuitivas, sistemas orientados a objetos, tecnologias integradas da Web e redes rápidas, tanto com fio quanto sem fio. A resposta é sim. Embora algumas aplicações não exijam explicitamente conteúdo algorítmico no nível da aplicação (como algumas aplicações simples baseadas na Web), muitas o fazem. Por exemplo, considere um serviço baseado na Web que determina como viajar de um local para outro. Sua implementação dependeria de hardware rápido, uma interface gráfica do usuário, redes de área ampla e também possivelmente de orientação a objetos. No entanto, também exigiria algoritmos para certas operações, como encontrar rotas (provavelmente usando um algoritmo de caminho mais curto), render
izar mapas e interpolar endereços. Além disso, mesmo uma aplicação que não requer conteúdo algorítmico no nível da aplicação depende muito de algoritmos. A aplicação depende de hardware rápido? O design de hardware usado algoritmos. A aplicação depende de interfaces gráficas de usuário? O design de qualquer GUI depende de algoritmos. A aplicação depende de redes? O roteamento em redes depende muito de algoritmos. A aplicação foi escrita em uma linguagem diferente do código de máquina? Então, ela foi processada por um compilador, interpretador ou montador, todos os quais fazem amplo uso de algoritmos. Os algoritmos estão no cerne da maioria das tecnologias usadas em computadores contemporâneos. Além disso, com as capacidades cada vez maiores dos computadores, os usamos para resolver problemas maiores do que nunca. Como vimos na comparação acima entre ordenação por inserção e merge sort, é em tamanhos de problemas maiores que as diferenças de eficiência entre algoritmos se tornam particularmente proeminentes. Ter uma base sólida de conhecimento e técnica algorítmica é uma característica que separa os programadores verdadeiramente habilidosos dos novatos. Com a tecnologia moderna de computação, você pode realizar algumas tarefas sem saber muito sobre algoritmos, mas com um bom conhecimento em algoritmos, você pode fazer muito, muito mais.
